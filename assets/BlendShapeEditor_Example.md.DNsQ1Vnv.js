import{_ as a,c as o,o as t,ap as i,aG as p,aH as r,aI as c,aJ as d,aK as n,aL as s,aM as l}from"./chunks/framework.Bw-F2Jup.js";const B=JSON.parse('{"title":"准备工作","description":"","frontmatter":{"prev":{"text":"插件介绍","link":"BlendShapeEditor/Description"},"next":false},"headers":[],"relativePath":"BlendShapeEditor/Example.md","filePath":"BlendShapeEditor/Example.md"}'),h={name:"BlendShapeEditor/Example.md"};function _(g,e,f,m,u,x){return t(),o("div",null,[...e[0]||(e[0]=[i('<h1 id="准备工作" tabindex="-1">准备工作 <a class="header-anchor" href="#准备工作" aria-label="Permalink to “准备工作”">​</a></h1><p>单击下方链接来下载二次修改和分发的 *.unitypackage 文件： <a href="https://hrenact.github.io/HrenactNET/Files/BlendShapeEditor.unitypackage" target="_blank" rel="noreferrer">https://hrenact.github.io/HrenactNET/Files/BlendShapeEditor.unitypackage</a></p><p>双击下载好的文件，或拖入 Unity 中 Project 窗口的 Assets 文件夹内，弹出导入窗口，单击<code>Import</code>来导入。</p><p>将鼠标移至 Unity 编辑栏的<code>Tools</code>选项，在浮现的窗口中单击<code>BlendShape Editor</code>选项，打开插件窗口。</p><p>选中你需要修复的模型的 Root，按下 Ctrl + D 创建副本，隐藏原始模型，在副本上进行模型的修改操作。</p><p>在开始使用此工具前，你应该先检查对应的 Skinned Mesh Renderer 组件物体上是否拥有<code>AAO Freeze BlendShapes</code>组件。如果拥有此组件，请先移除它，并在结束使用工具后重新添加。</p><figure><img src="'+p+'" alt="AAORemove" tabindex="0"><figcaption>AAORemove</figcaption></figure><h1 id="开始使用" tabindex="-1">开始使用 <a class="header-anchor" href="#开始使用" aria-label="Permalink to “开始使用”">​</a></h1><p>将你拥有 MMD 形态键的物体拖入至<code>Skinned Mesh Renderer 槽</code>内，在<code>排序 &amp; 重命名</code>选项卡内找到对应的会穿模的形态键，复制它的名称。</p><figure><img src="'+r+'" alt="photo1" tabindex="0"><figcaption>photo1</figcaption></figure><p>转到<code>创建</code>选项卡，在 BlendShape 列表内选择对应的形态键，调整数值至刚好不会穿模，修改新 Blendshape 名称为<code>你正在修复的形态键名称_new</code>，单击<code>创建 BlendShape</code>并稍等片刻，即可完成新形态键的制作。</p><figure><img src="'+c+'" alt="photo2" tabindex="0"><figcaption>photo2</figcaption></figure><p>如果你的脸型独特到调整单一的形态键无法解决，你可以单击 BlendShape 列表下方的 添加 + 来添加新的形态键并调整数值直到你满意为止。</p><figure><img src="'+d+'" alt="photo2_1" tabindex="0"><figcaption>photo2_1</figcaption></figure><p>转到<code>排序 &amp; 重命名</code>选项卡，翻到最底部，将新形态键移动至原始形态键上方，为原始形态键添加 <code>_backup</code> 后缀，并删除新形态键的<code>_new</code>后缀。</p><figure><img src="'+n+'" alt="photo3" tabindex="0"><figcaption>photo3</figcaption></figure><figure><img src="'+s+'" alt="photo3_1" tabindex="0"><figcaption>photo3_1</figcaption></figure><p>此选项卡不支持<code>撤回 Ctrl + Z</code>操作，如果进行了误操作，可以单击页面底部的<code>重置 Blendshape 修改</code>按钮来重置形态键顺序和名称。</p><p>修改完成后，单击<code>应用 Blendshape 修改</code>来保存新形态键顺序和名称，转到原始物体的<code>Inspector</code>并将原始形态键的值调为 0 ，此时我们就完成此 MMD 形态键的穿模问题，以此类推，哪些会穿模就修哪些。</p><figure><img src="'+l+'" alt="photo4" tabindex="0"><figcaption>photo4</figcaption></figure>',20)])])}const b=a(h,[["render",_]]);export{B as __pageData,b as default};
