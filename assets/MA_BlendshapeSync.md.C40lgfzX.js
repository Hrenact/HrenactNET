import{_ as a,c as n,o as d,aC as c,a_ as r,a$ as l,b0 as s}from"./chunks/framework.eR779Ogb.js";const y=JSON.parse('{"title":"同步形态键 / Blendshape Sync","description":"","frontmatter":{"prev":false,"next":false},"headers":[],"relativePath":"MA/BlendshapeSync.md","filePath":"MA/BlendshapeSync.md"}'),p={name:"MA/BlendshapeSync.md"};function i(t,e,o,h,B,S){return d(),n("div",null,[...e[0]||(e[0]=[c('<h1 id="同步形态键-blendshape-sync" tabindex="-1">同步形态键 / Blendshape Sync <a class="header-anchor" href="#同步形态键-blendshape-sync" aria-label="Permalink to “同步形态键 / Blendshape Sync”">​</a></h1><figure><img src="'+r+'" alt="BlendshapeSync" tabindex="0"><figcaption>BlendshapeSync</figcaption></figure><p><code>Blendshape Sync</code> 组件允许你始终将一个 Renderer 中指定的形态键与另一个 Renderer 中指定形态键的值相同。</p><video controls width="100%"><source src="'+l+'" type="video/mp4"></video><h2 id="何时应使用" tabindex="-1">何时应使用？ <a class="header-anchor" href="#何时应使用" aria-label="Permalink to “何时应使用？”">​</a></h2><p>通常，模型的身体 Renderer 拥有一系列形态键用来调整外观。如果你正在为模型添加（或创建）服装，并且该服装拥有与之匹配的形态键，那 Blender Sync 就是您的不二之选！</p><p>当然，你也可以用来在不同的对象之间同步形态键，用法完全取决于你。</p><h2 id="何时不应使用" tabindex="-1">何时不应使用？ <a class="header-anchor" href="#何时不应使用" aria-label="Permalink to “何时不应使用？”">​</a></h2><p><code>Blender Sync</code> 始终将某个 Renderer 的混合形状数值完全复制到另一个渲染器。若目标对象需要不同的缩放比例或动画曲线，该功能将无法正确运作。</p><p><code>Blender Sync</code> 不支持串用操作—— 即可以从 A 复制到 B 和 A 到 C，但不能实现从 A 到 B 再经由 B 复制到 C 的链式传输。</p><p>在运行时，<code>Blender Sync</code> 仅支持同步由动画控制的形态键。由 VRchat 内部所控制的 Eyelook 和 自动口型系统将难以准确同步。</p><h2 id="设置-blendshape-sync" tabindex="-1">设置 Blendshape Sync <a class="header-anchor" href="#设置-blendshape-sync" aria-label="Permalink to “设置 Blendshape Sync”">​</a></h2><p>在你预制件中的对象上挂载 Blendshape Sync 组件，然后单击 <code>+</code> 按钮来打开选择窗口。</p><figure><img src="'+s+'" alt="SetBlendshapeSync" tabindex="0"><figcaption>SetBlendshapeSync</figcaption></figure><h2 id="工作原理" tabindex="-1">工作原理 <a class="header-anchor" href="#工作原理" aria-label="Permalink to “工作原理”">​</a></h2><p><code>Blendshape Sync</code> 有两个功能：</p><ul><li>在编辑模式下：它会复制基础对象的 Blendshape 值并自动应用，因此对基础对象 Shapekey 的更改都会立即影响其它对象。</li><li>在播放模式下：它会修改所有有关的动画，根据基础对象的 Blendshape 动画同步生成其它对象的 Blendshape 动画。</li></ul>',17)])])}const f=a(p,[["render",i]]);export{y as __pageData,f as default};
