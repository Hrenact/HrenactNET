import{_ as a,c as r,o,aC as t,b5 as n,b6 as c}from"./chunks/framework.CFe3CgxF.js";const f=JSON.parse('{"title":"菜单项 / Menu Item","description":"","frontmatter":{"prev":false,"next":false},"headers":[],"relativePath":"MA/MenuItem.md","filePath":"MA/MenuItem.md"}'),d={name:"MA/MenuItem.md"};function i(s,e,l,u,m,p){return o(),r("div",null,[...e[0]||(e[0]=[t('<h1 id="菜单项-menu-item" tabindex="-1">菜单项 / Menu Item <a class="header-anchor" href="#菜单项-menu-item" aria-label="Permalink to “菜单项 / Menu Item”">​</a></h1><figure><img src="'+n+'" alt="Menu Item" tabindex="0"><figcaption>Menu Item</figcaption></figure><p><code>Menu Item</code> 组件允许你在 Unity Hierarchy 中定义一个轮盘菜单项。</p><h2 id="何时应使用" tabindex="-1">何时应使用？ <a class="header-anchor" href="#何时应使用" aria-label="Permalink to “何时应使用？”">​</a></h2><p>该组件可以比定义 VRC Expressions Menu 资源提供更方便的方式来编辑和定义菜单项。你可以通过在层级中拖放来移动菜单项，并且它提供了一个编辑器界面，可以识别 MA <a href="./Parameters"><code>Parameters</code></a> 组件上定义的参数名称。</p><h2 id="该如何使用" tabindex="-1">该如何使用？ <a class="header-anchor" href="#该如何使用" aria-label="Permalink to “该如何使用？”">​</a></h2><p><code>Menu Item</code> 组件定义了更大的菜单中的单个菜单项。您可以为菜单项配置图标、菜单类型和参数。菜单项的名称将取自其挂载的游戏对象的名称。这使您可以在层级视图中直接查看菜单项的名称并重命名它们。</p><h3 id="子菜单" tabindex="-1">子菜单 <a class="header-anchor" href="#子菜单" aria-label="Permalink to “子菜单”">​</a></h3><p>当菜单项被设置为子菜单时，您可以配置子菜单的来源。您可以将 <code>Submenu Source</code> 设置为 <code>Expressions Menu Asset</code>，并配置一个传统的 VRC Expressions Menu 资源以供引用，或者您可以将 <code>Submenu Source</code> 设置为 <code>Children</code>，这种情况下，附加在该菜单项直接子集上的 <code>Menu Item</code> 将用于填充子菜单。</p><p>如果子菜单中的项目数量超过 VRC 菜单的最大项目数，将会自动创建一个“next”项目以分割菜单。</p><p>当子菜单来源为子集时，您还可以指定一个 <code>Source Object Override</code>。如果设置了该项，将使用该对象的子集，而不是菜单项的直接子集。</p><h3 id="绑定子菜单" tabindex="-1">绑定子菜单 <a class="header-anchor" href="#绑定子菜单" aria-label="Permalink to “绑定子菜单”">​</a></h3><p>为了确定菜单项在菜单中的位置，需要另一个组件将其绑定到菜单。有三种方法可以实现这一点：</p><ul><li>通过 <code>submenu</code> 或 <code>children</code> 模式，可以将 <code>Menu Item</code> 设置为另一个 <code>Menu Item</code> 的子项。</li><li><code>Menu Item</code> 可以与 <a href="./MenuInstaller"><code>Menu Installer</code></a> 组件位于同一个游戏对象上。</li><li><code>Menu Item</code> 可以是 <a href="./MenuGroup"><code>Menu Group</code></a> 对象的子项（通常此对象位于带有 <code>Menu Installer</code> 组件的游戏对象上）。</li></ul><p>未绑定的菜单项不会产生任何效果。</p><h3 id="自动创建参数" tabindex="-1">自动创建参数 <a class="header-anchor" href="#自动创建参数" aria-label="Permalink to “自动创建参数”">​</a></h3><p>当你指定一个在 MA <a href="./Parameters"><code>Parameters</code></a> 组件或 VRC Expressions Parameter 资产中未声明的参数名称时，<code>Menu Item</code> 会自动为你创建一个参数。发生这种情况时，你会看到一些复选框，用于控制值是否被保存/同步。</p><figure><img src="'+c+'" alt="Automatic Parameter Creation" tabindex="0"><figcaption>Automatic Parameter Creation</figcaption></figure><p>如果你勾选 <code>Is Default</code>，此菜单项将被设置为该参数的默认值。如果有多个菜单项勾选了 <code>Is Default</code>，结果将无法预测。请不要这样做！</p><p>如果你的菜单项没有设置参数名称，你仍然会看到这些选项；如果此菜单项有控制任何的反应式组件对象，将会创建一个参数。</p>',20)])])}const M=a(d,[["render",i]]);export{f as __pageData,M as default};
