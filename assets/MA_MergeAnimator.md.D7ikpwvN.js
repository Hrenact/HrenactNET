import{_ as a,c as o,a2 as r,o as t}from"./chunks/framework.Bm4S-XEE.js";const i="/HrenactNET/images/MA/MergeAnimator.png",d="/HrenactNET/images/MA/MergeAnimatorRA.png",g=JSON.parse('{"title":"合并动画控制器 / Merge Animator","description":"","frontmatter":{"prev":false,"next":false},"headers":[],"relativePath":"MA/MergeAnimator.md","filePath":"MA/MergeAnimator.md","lastUpdated":null}'),n={name:"MA/MergeAnimator.md"};function c(m,e,l,h,A,s){return t(),o("div",null,e[0]||(e[0]=[r('<h1 id="合并动画控制器-merge-animator" tabindex="-1">合并动画控制器 / Merge Animator <a class="header-anchor" href="#合并动画控制器-merge-animator" aria-label="Permalink to &quot;合并动画控制器 / Merge Animator&quot;">​</a></h1><p><img src="'+i+'" alt="Merge Animator"></p><p><code>Merge Animator</code> 组件将把提供的 Animator 添加到它所附加的模型的指定层。这可以用来制作复杂的 AV3 噱头，只需拖放到模型上即可安装。</p><h2 id="何时应使用" tabindex="-1">何时应使用？ <a class="header-anchor" href="#何时应使用" aria-label="Permalink to &quot;何时应使用？&quot;">​</a></h2><p>当你想将动画作为你噱头的一部分播放时，请使用 <code>Merge Animator</code> 组件。</p><h2 id="何时不应使用" tabindex="-1">何时不应使用？ <a class="header-anchor" href="#何时不应使用" aria-label="Permalink to &quot;何时不应使用？&quot;">​</a></h2><p><code>Merge Animator</code> 组件会添加到现有的 Animator Layer，但不会替换它们。如果你希望最终用户完全替换某个 Animator Layer，最好让他们通过传统方式在 Avatar Descriptor 中进行替换。</p><h2 id="设置-merge-animator" tabindex="-1">设置 Merge Animator <a class="header-anchor" href="#设置-merge-animator" aria-label="Permalink to &quot;设置 Merge Animator&quot;">​</a></h2><p>将 <code>Merge Animator</code> 组件添加到预制件中的对象，并在 <code>Animator to merge</code> 字段中添加 Animator。将 <code>Layer Type</code> 字段设置为应添加此动画的模型动画层（例如：FX）。</p><h3 id="录制动画" tabindex="-1">录制动画 <a class="header-anchor" href="#录制动画" aria-label="Permalink to &quot;录制动画&quot;">​</a></h3><p>默认情况下，Animator 中的路径被解释为相对于 <code>Merge Animator</code> 组件的路径。这使得录制新动画变得容易，前提是你正在为 <code>Merge Animator</code> 组件下的对象制作动画。</p><p>只需将一个 <code>Animator</code> 组件附加到你的游戏对象上，就可以通过 Animation 面板来录制动画：</p><p><img src="'+d+'" alt="Recording animations"></p><p>为了方便开发，你可以勾选 <code>Delete attached animator</code> 选项，以在构建时移除 <code>Animator</code> 组件。</p><h3 id="人形骨骼动画" tabindex="-1">人形骨骼动画 <a class="header-anchor" href="#人形骨骼动画" aria-label="Permalink to &quot;人形骨骼动画&quot;">​</a></h3><p>移动人形骨骼的动画会忽略相对路径逻辑，并且总是作用于整个角色。因此，大多数人形动画（例如 AFK 动画）是可以直接使用的。</p><h3 id="路径模式-path-mode" tabindex="-1">路径模式 / Path mode <a class="header-anchor" href="#路径模式-path-mode" aria-label="Permalink to &quot;路径模式 / Path mode&quot;">​</a></h3><p><code>Path mode</code> 选项控制动画路径的解释方式。在 <code>Relative</code> 模式下，所有路径都是相对于一个特定对象的，通常是附加了 <code>Merge Animator</code> 组件的对象。这允许你创建在模型层级中移动后仍然有效的噱头，并通过使用 Unity <code>Animator</code> 组件（如上所述）更容易的录制动画。你可以通过设置 <code>Relative Path Root</code> 字段来控制在动画中使用哪个对象作为路径的 Root。</p><p>如果你想要为已经附加到模型的对象（不在你的对象下）制作动画，请将 <code>Path mode</code> 设置为<code>Absolute</code>。这将使动画器使用绝对路径，不会尝试以 <code>Merge Animator</code> 组件为相对路径的参考。这意味着你需要使用角色的 Root 动画器来录制你的动画。</p><h3 id="图层优先级-layer-priority" tabindex="-1">图层优先级 / Layer Priority <a class="header-anchor" href="#图层优先级-layer-priority" aria-label="Permalink to &quot;图层优先级 / Layer Priority&quot;">​</a></h3><p><code>Layer Priority</code> 控制着 <code>Merge Animator</code> 组件的应用顺序。它们将在最终动画器中按优先级递增的顺序排列（即，数字较低的位于 Animator 列表前面，而数字较高的则会盖过它们）。具有相同优先级的 <code>Merge Animator</code> 将按它们在层次结构中的顺序排列。任何已有的 Animator 优先级都被视为零，位于所有优先级为零的 <code>Merge Animator</code> 前面。</p><h3 id="合并模式-merge-mode" tabindex="-1">合并模式 / Merge Mode <a class="header-anchor" href="#合并模式-merge-mode" aria-label="Permalink to &quot;合并模式 / Merge Mode&quot;">​</a></h3><p>默认情况下，<code>Merge Animator</code> 会将 Animator 添加到指定的层。如果你想替换该层，请将 <code>Merge Mode</code> 设置为 <code>Replace Existing Animator</code>。这将用你提供的 Animator 替换 VRChat Descriptor 上配置的任何 Animator。</p><p>被替换的 Animator 将保持你指定的优先级，但它将在该优先级级别的其他 <code>Merge Animator</code> 之前应用。</p><p>将多个 <code>Merge Animator</code> 设置为相同的 <code>Layer Type</code> 和替换模式将导致错误。</p><h3 id="写入默认值-write-defaults" tabindex="-1">写入默认值 / Write Defaults <a class="header-anchor" href="#写入默认值-write-defaults" aria-label="Permalink to &quot;写入默认值 / Write Defaults&quot;">​</a></h3><p>默认情况下，Animator 的 Write Defaults 不会被更改。如果你希望确保 Animator 状态的 WD 设置始终与模型的 Animator 匹配，请勾选 <code>Match Avatar Write Defaults</code>。此操作将检测模型是否在使用 Write Defaults 时始终保持开启或关闭状态，如果是，则会调整你的 Animator 以匹配。如果模型使用的 Write Defaults 不一致，你的 Animator 将保持不变。</p><h2 id="限制" tabindex="-1">限制 <a class="header-anchor" href="#限制" aria-label="Permalink to &quot;限制&quot;">​</a></h2><h3 id="vrcanimatorlayercontrol" tabindex="-1">VRCAnimatorLayerControl <a class="header-anchor" href="#vrcanimatorlayercontrol" aria-label="Permalink to &quot;VRCAnimatorLayerControl&quot;">​</a></h3><p>目前，<code>Merge Animator</code> 仅支持引用同一 Animator 内图层的 VRCAnimatorLayerControl 状态行为。如果您打算使用此功能，请确保 <code>Playable</code> 字段与 <code>Merge Animator</code> 组件上设置的 <code>Layer</code> 匹配，并将 <code>Layer</code> 字段设置为 Animator 中图层的索引。</p>',30)]))}const M=a(n,[["render",c]]);export{g as __pageData,M as default};
