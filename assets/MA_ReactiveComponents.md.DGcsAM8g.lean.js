import{_ as a,c as t,a2 as l,o}from"./chunks/framework.Bm4S-XEE.js";const u=JSON.parse('{"title":"反应式组件","description":"","frontmatter":{"prev":false,"next":false},"headers":[],"relativePath":"MA/ReactiveComponents.md","filePath":"MA/ReactiveComponents.md","lastUpdated":null}'),i={name:"MA/ReactiveComponents.md"};function r(n,e,c,p,s,d){return o(),t("div",null,e[0]||(e[0]=[l('<h1 id="反应式组件" tabindex="-1">反应式组件 <a class="header-anchor" href="#反应式组件" aria-label="Permalink to &quot;反应式组件&quot;">​</a></h1><p>反应式组件是指能够根据其游戏对象的活动状态将某些效果应用于模型的组件（以及父项），或 <code>Menu Item</code> 的开启状态。它将允许你创建简单的开关、更换服装时调整形态键等等——并且无需手动录制任何动画。</p><p>目前有以下几种反应式组件可供使用：</p><ul><li><a href="./ReactiveComponents/ObjectToggle">Object Toggle</a> - 控制游戏对象的启用状态</li><li><a href="./ReactiveComponents/ShapeChanger">Shape Changer</a> - 修改目标渲染器上的形态键</li><li><a href="./ReactiveComponents/MaterialSetter">Material Setter</a> - 更改目标渲染器上的材质球</li><li><a href="./ReactiveComponents/MaterialSwap">Material Swap</a> - 交换目标渲染器上的材质球</li></ul><h2 id="反应式组件基础规则" tabindex="-1">反应式组件基础规则 <a class="header-anchor" href="#反应式组件基础规则" aria-label="Permalink to &quot;反应式组件基础规则&quot;">​</a></h2><p>一般来说，响应式组件在 <em>激活</em> 时会应用某种效果。反应式组件将在以下情况时处于激活状态：</p><ul><li>其游戏对象和所有父对象在 Hierarchy 中处于启用状态。</li><li>如果反应式对象与 <code>Menu Item</code> 位于同一游戏对象上，或者位于 <code>Menu Item</code> 的子对象上，则 <code>Menu Item</code> 将被选择。 <ul><li>请注意：仅第一个父 <code>Menu Item</code> 将会被考虑（父 Submenus 将被忽略）。</li></ul></li></ul><p>成功构建模型后，反应式组件将对以下行为做出响应：</p><ul><li>对游戏对象状态进行更改的动画</li><li>影响其它反应式组件的启用状态的对象开关</li><li>选择菜单项</li></ul><p>你也可以启用 <code>Invert condition</code> 选项：在这种情况下，上述条件将被 <em>反转</em> 。</p><h3 id="规则优先级" tabindex="-1">规则优先级 <a class="header-anchor" href="#规则优先级" aria-label="Permalink to &quot;规则优先级&quot;">​</a></h3><p>如果多个反应式组件同时处于启用状态，并且它们的效果冲突（例：一个试图关闭游戏对象，但另一个试图打开游戏对象），则 Hierarchy 中最底部的组件优先。</p><h3 id="反应时间" tabindex="-1">反应时间 <a class="header-anchor" href="#反应时间" aria-label="Permalink to &quot;反应时间&quot;">​</a></h3><div class="warning custom-block"><p class="custom-block-title">警告</p><p>随着我们不断的优化，反应式组件激活的精确时间在未来可能会发生改变。 对于复杂的效果实现，你 <strong>不应该依赖于反应式组件的响应时间</strong> 。</p></div><p>游戏对象的状态变化将在反应式组件变化的一帧延迟后响应，当游戏对象被要求禁用时，游戏对象的实际禁用将在同一时间延迟一帧。请参阅 Shape Changer 以了解有关该行为的更多信息。</p><p>如果一个响应式组件控制着另一个响应式组件的状态，那么每个响应式组件的切换都将会被延迟一帧。因此，如果你制作了 A-&gt;B-&gt;C ，且 A 正被关闭，则顺序如下：</p><ul><li>第 1 帧：无事发生（A 处于禁用延迟）</li><li>第 2 帧：A 被禁用（B 处于禁用延迟）</li><li>第 3 帧：B 和 C 同时被禁用。</li></ul><h3 id="调试问题" tabindex="-1">调试问题 <a class="header-anchor" href="#调试问题" aria-label="Permalink to &quot;调试问题&quot;">​</a></h3><p>反应式组件系统包括一个调试器，可以用于模拟打开或关闭各种对象或菜单项。要使用它，请右键单击对象，然后选择 <code>Modular Avatar -&gt; Show Reaction Debugger</code></p>',19)]))}const m=a(i,[["render",r]]);export{u as __pageData,m as default};
