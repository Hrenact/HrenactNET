import{_ as a,c,o as l,aC as t,bz as o}from"./chunks/framework.eR779Ogb.js";const _=JSON.parse('{"title":"替换对象 / Replace Object","description":"","frontmatter":{"prev":false,"next":false},"headers":[],"relativePath":"MA/ReplaceObject.md","filePath":"MA/ReplaceObject.md"}'),r={name:"MA/ReplaceObject.md"};function d(p,e,i,n,h,s){return l(),c("div",null,[...e[0]||(e[0]=[t('<h1 id="替换对象-replace-object" tabindex="-1">替换对象 / Replace Object <a class="header-anchor" href="#替换对象-replace-object" aria-label="Permalink to “替换对象 / Replace Object”">​</a></h1><figure><img src="'+o+'" alt="Replace Object" tabindex="0"><figcaption>Replace Object</figcaption></figure><p><code>Replace Object</code> 组件允许你完全替换父模型上游戏对象的内容。</p><h2 id="何时应使用" tabindex="-1">何时应使用？ <a class="header-anchor" href="#何时应使用" aria-label="Permalink to “何时应使用？”">​</a></h2><p>当你想用不同的物体替换父级模型上的某个物体时，<code>Replace Object</code> 组件非常有用。例如，你可能想替换基础头像的 PhysBones 配置，或者将其身体网格完全替换为不同的网格。</p><h2 id="何时不应使用" tabindex="-1">何时不应使用？ <a class="header-anchor" href="#何时不应使用" aria-label="Permalink to “何时不应使用？”">​</a></h2><p>一个对象只能被另一个对象替换。因此，当你使用 <code>Replace Object</code> 时，会限制你的资源与其它可能也想使用 <code>Replace Object</code> 的资源的兼容性。</p><h2 id="详细操作" tabindex="-1">详细操作 <a class="header-anchor" href="#详细操作" aria-label="Permalink to “详细操作”">​</a></h2><h3 id="处理子对象" tabindex="-1">处理子对象 <a class="header-anchor" href="#处理子对象" aria-label="Permalink to “处理子对象”">​</a></h3><p><code>Replace Object</code> 仅替换指定的特定对象。原对象和替换对象的子对象都会放在替换对象下。</p><h3 id="对象命名" tabindex="-1">对象命名 <a class="header-anchor" href="#对象命名" aria-label="Permalink to “对象命名”">​</a></h3><p><code>Replace Object</code> 不会更改替换对象的名称；如果它的名称与原始对象不同，则最终对象名称将不同。然而，<code>Replace Object</code> 会将引用原始对象的任何动画路径更新为引用的替换对象。</p><p>由于 <code>Replace Object</code> 是在模型处理的相对较晚阶段执行的，在大多数情况下这并不会带来太大区别。然而，如果—— 例如—— 你想要替换 <code>Body</code> 网格并保持 MMD 世界的兼容性（或者，相反，想为现有模型添加 MMD 兼容性），这可能就很重要。</p><h3 id="组件引用的处理" tabindex="-1">组件引用的处理 <a class="header-anchor" href="#组件引用的处理" aria-label="Permalink to “组件引用的处理”">​</a></h3><p><code>Replace Object</code> 将尝试修正对旧对象上组件的任何引用，使其指向新对象。如果旧对象上有多个相同的组件，那么引用将与新对象中相同索引的组件匹配（如果新对象中没有足够该类型的组件，则引用将被置为 Null）。</p><p><code>Replace Object</code> 不会执行模糊匹配；例如，如果你将 Box Collider 替换为 Sphere Collider，对旧 Box Collider 的引用将变为 Null。</p>',16)])])}const f=a(r,[["render",d]]);export{_ as __pageData,f as default};
